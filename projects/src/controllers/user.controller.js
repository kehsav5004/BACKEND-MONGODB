import { asynchandler } from "../utils/asynchandler.js";
import {apierror} from "../utils/apierror.js";
import { User } from "../models/user.model.js";   // we aer using this to interact with users database to trim data
import { uploadoncloudinary } from "../utils/cloudinary.js"; // to upload file on cloudinary 
import { apiresponse } from "../utils/apiresponse.js";  // we are using this return the response
import mongoose from "mongoose";

const generateaccessandrefreshtoken = async(userId) => {   // tokens are to be generated by taking userid value
   try {
      const user = await User.findById(userId)
      const accesstoken = user.generateaccesstoken()
      const refreshtoken = user.generaterefreshtoken()

      user.refreshtoken = refreshtoken             // here  its taking refresh token from userid
      await user.save({validatebeforesave : false})  // to save the refresh id into database 

      return {accesstoken, refreshtoken}  // returning both the tokens where access will be temporaray and the refrsh will be for longer time
   } catch (error) {
      throw new apierror(500,"something went wrong while generating access and refresh token")
   }
}
 
const registeruser = asynchandler(async(req, res) => {  // this will recieve and send response to he user for registration
   const{fullname, email, username, password} = req.body
   console.log("BODY:", req.body);
  console.log("FILES:", req.files);


// checking if some fileds are empty or nit
  if ([fullname, email, username, password].some((field) => field?.trim() === ""))
   {
      throw new apierror(400, "all fields are required") 
   }


// checking if user already exists
   const existeduser = await User.findOne({ $or: [{email}, {username}] }); // .findone to find any of the mentioned 

   if (existeduser) {
      throw new apierror(400, "user already exists")
   }


   //adding file by multer
   console.log("FILES RECEIVED:", req.files);

   const avatarlocalpath = req.files?.avatar?.[0]?.path;  //[0] gives the file type either json or anything and it spath
   const coverimagelocalpath = req.files?.coverimage?.[0]?.path;

   console.log("Avatar path:", avatarlocalpath);
   console.log("Cover image path:", coverimagelocalpath);

   //checking if avatar is arrived in localpath or not
   if (!avatarlocalpath) {
      console.log("Avatar path is falsy:", avatarlocalpath);
      throw new apierror(400, "avatar is required")
   }

   console.log("About to upload avatar to cloudinary...");

   //uploading files on cloudinary
   const avatar =  await uploadoncloudinary(avatarlocalpath)
   console.log("Avatar upload result:", avatar);
   
   const coverimage =  await uploadoncloudinary(coverimagelocalpath)
   console.log("Cover image upload result:", coverimage);

   if(!avatar){
      console.log("Avatar upload failed - avatar is falsy");
      throw new apierror(400, "avatar is required")
   }

   console.log("About to create user in database...");

   //creating objedct to enter detail in db
   const user = await User.create({ 
      fullname,
      email,
      username: username.toLowerCase(),
      password,
      avatar: avatar.url,
      coverimage: coverimage?.url || "",
   })

   // removing refresh token 
   const createduser = await User.findById(user._id).select("-refreshToken") // here we aree using(.select)(-password)to remove the this element
   if (!createduser) {
      throw new apierror(500, "somethimg went wrong")
   }


   //returning respone
   return res.status(201).json(
      new apiresponse(201, createduser, "user created successfully")
   )
})

const loginuser = asynchandler(async(req,res) => {  // this is for login user
   const{email, password, username} = req.body
   console.log("email:", email)
   console.log("password :",password) // tking info required for login

   if (!(username || email)) {
      throw new apierror(400, "username and email are required")
   }

   const user = await User.findOne({   // finding whether by username or email
      $or : [{username}, {email}]
   })

   if (!user) {
      throw new apierror(404, "user  not found")
   }

   const ispasswordvalid = await user.ispasswordcorrect(password)  // taking password 

   if (!ispasswordvalid) {
      throw new apierror(401, "invalid credentials")
   }

   const {accesstoken, refreshtoken} = await generateaccessandrefreshtoken(user._id)

   const loggedinuser = await User.findById(user._id).select("-password -refreshtoken")

   const options = {          // cookie flags
      httpOnly: true,
      secure: true,         // set true only behind HTTPS (prod)
   }
   const response = new apiresponse(200, {
      loggedinuser, accesstoken, refreshtoken
   },"user logged in succesfully");
   console.log("Login successful response sent:", response);

   return res
   .status(200)
   .cookie("accesstoken", accesstoken, options)
   .cookie("refreshtoken", refreshtoken, options)
   .json(response)
})

const logoutuser = asynchandler(async(req, res) => {
   await User.findByIdAndUpdate(
      req.user._id,
      {
         $unset:{
            refreshtoken : 1
         }
      },
      {
        new : true
      }
   )
   const options = {          // cookie flags
      httpOnly: true,
      secure: true,
   }

   return res
   .status(200)
   .clearCookie("accesstoken",  options)
   .clearCookie("refreshtoken", options)
   .json(
      new apiresponse(200, {},"user logged out succesfully ")
   )
})

const refreshaccesstoken = asynchandler(async (req, res) => {
   const incomingrefreshtoken = req.cookies.refreshtoken || req.body.refreshtoken

   if (!incomingrefreshtoken) {
       throw new apierror(401, "unauthorized request")
   }

   try {
       const decodedtoken = jwt.verify(
           incomingrefreshtoken,
           process.env.refresh_token_secret
       )
   
       const user = await User.findById(decodedtoken?._id)
   
       if (!user) {
           throw new apierror(401, "Invalid refresh token")
       }
   
       if (incomingrefreshtoken !== user?.refreshtoken) {
           throw new apierror(401, "Refresh token is expired or used")
           
       }
   
       const options = {
           httpOnly: true,
           secure: true
       }
   
       const {accesstoken, newrefreshtoken} = await generateAccessAndRefereshTokens(user._id)
   
       return res
       .status(200)
       .cookie("accesstoken", accessToken, options)
       .cookie("refreshtoken", newrefreshtoken, options)
       .json(
           new apiresponse(
               200, 
               {accesstoken, refreshtoken: newrefreshtoken},
               "Access token refreshed"
           )
       )
   } catch (error) {
       throw new apierror(401, error?.message || "Invalid refresh token")
   }

})

const changepassword = asynchandler(async (req, res) => {
    const {oldpassword, newpassword} = req.body
    const user = await User.findById(req.user?._id)
    const ispasswordcorrect = await user.ispasswordcorrect(oldpassword)

    if (!ispasswordcorrect) {
      throw new apierror(400, "invalid password")
    }

    user.password = newpassword
    await user.save({validatebeforesave: false})

    const response = new apiresponse(200,{},"password changed successfuly");
    console.log("change password successfuly response:", response)

    return res
    .status(200)
    .json(response)

})

const getcurrentuser = asynchandler(async(req,res) => {
   const response = new apiresponse(200, req.user, "current user fetched successfully");
   console.log("Current user fetched response:", response);
   return res
   .status(200)
   .json(response)
})

const updateacountdetails = asynchandler(async(req,res) => {
   const{fullname, email} = req.body

   if (!fullname || !email) {
      throw new apierror(400, "fullname or email required")
   }

   const user = await User.findByIdAndUpdate(
      req.user?._id,
      {
         $set : {
            fullname,
            email,
         }
      },
      {new:true}
   ).select("-password")
   return res
   .status(200)
   .json(new apiresponse(200, user, "user details updated successfully"))
})

const updateuseravatar = asynchandler(async(req,res) => {
   const avatarlocalpath = req.file?.path

   if (!avatarlocalpath) {
      throw new apierror(400, "avatar is required")
   }

   const avatar = await uploadoncloudinary(avatarlocalpath)

   if (!avatar.url) {
      throw new apierror(400, "error while uploading avatar")
   }

   const user = await User.findByIdAndUpdate(
      req.user?._id,
      {
         $set : {
            avatar:avatar.url,
         }
      },
      {new:true}
   ).select("-password")
   
   return res
   .status(200)
   .json(new apiresponse(200, user, "user avatar updated successfully"))
})

const updateusercoverimage = asynchandler(async(req,res) => {
   const coverimagelocalpath = req.file?.path

   if (!coverimagelocalpath) {
      throw new apierror(400, "coverimage is required")
   }

   const coverimage = await uploadoncloudinary(coverimagelocalpath)

   if (!coverimage.url) {
      throw new apierror(400, "error while uploading avatar")
   }

   const user = await User.findByIdAndUpdate(
      req.user?._id,
      {
         $set : {
            coverimage : coverimage.url
         }
      },
      {new:true}
   ).select("-password")
   
   return res
   .status(200)
   .json(new apiresponse(200, user, "user coverimage updated successfully"))
})

const getuserchannelprofile = asynchandler(async(req,res) => {
   const {username} = req.params

   if (!username?.trim()) {
      throw new apierror(400, "username is required")
   }

   const channel = await User.aggregate([
      {
         $match:{
            username : username?.toLowerCase()
         }
      },
      {
         $lookup:{
            from:"subscription",
            localField:"_id",
            foreignField:"channel",
            as:"subscribers"
         }
      },
      {
         $lookup:{
            from:"subscription",
            localField:"_id",
            foreignField:"subscriber",
            as:"subscribedto",
         }
      },
      {
         $addFields:{
            subscriberscount:{
               $size:"$subscribers"
            },
            channelsubscribedtocount:{
               $size:"$subscribedto"
            },
            issubscribed:{
               $cond:{
                  if:{$in: [req.user?._id,"$subscribers.subscriber"]},
                  then:true,
                  else:false
               }
            }
         }
      },
      {
         $project:{
            username:1,
            fullname:1,
            subscriberscount:1,
            channelsubscribedtocount:1,
            issubscribed:1,
            avatar:1,
            coverimage:1,
         }
      }
   ])

   if(!channel?.length){
      throw new apierror(404,"channel not found")
   }
   return res
   .status(200)
   .json(
      new apiresponse(200, channel[0], "user channel fetched successfully")
   )
})

const getwatchhistory = asynchandler(async(req,res) => {
   const user = await User.aggregate([
      {
         $match:{
            _id: new mongoose.Types.ObjectId(req.user._id)
         }
      },
      {
         $lookup: {
             from: "videos",
             localField: "watchhistory",
             foreignField: "_id",
             as: "watchhistory",
             pipeline: [
                 {
                     $lookup: {
                         from: "users",
                         localField: "owner",
                         foreignField: "_id",
                         as: "owner",
                         pipeline: [
                             {
                                 $project: {
                                     fullname: 1,
                                     username: 1,
                                     avatar: 1
                                 }
                             }
                         ]
                     }
                 },
                 {
                     $addFields:{
                         owner:{
                             $first: "$owner"
                         }
                     }
                 }
             ]
         }
     }
   ])
   return res
    .status(200)
    .json(
        new apiresponse(
            200,
            user[0].watchhistory,
            "Watch history fetched successfully"
        )
    )
})



export {registeruser};
export {loginuser};
export {logoutuser};
export {refreshaccesstoken};
export {changepassword};
export {getcurrentuser};
export {updateacountdetails};
export {updateuseravatar};
export {updateusercoverimage};
export {getuserchannelprofile};
export {getwatchhistory};